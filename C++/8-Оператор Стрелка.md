##Урок №8 С++ 
##Оператор доступа к членам через указатель (Оператор стрелка) ->

У нас имеется 2 типа операторов, оператов `&` торый позволяет поулчить 
ссылку на адрес в памяти где хранится значение переменной.

    int a = 5;

    cout << a << endl;
    cout << &a << endl;

    Ответ:
        5
        0xDKGJHJKCJ

Есть противоположный оператор `*` который позволяет по адресу в памяти
получить ее значение.

    int a = 7;

    cout << a << endl;
    cout << &a << endl;
    cout << *&a << endl;

    Ответ:
        7
        0xDKGJHJKCJ
        7

Это все работает прекрасно, когда мы делаем Указатель на обычную переменную,
но мы можем также ссылаться и на Структуры, создадим указатель на структуру
и вызовем ее.

    struct Custom
    {
        int id;
        char name[50];
    };

    Custom cst = {1, "Имя"};
    // Указатель содержит в себе ссылку на структуру
    Custom *pointerCst = &cst; 

Таким образом мы создали Структуру и определили ее в переменной `sct`
после мы создаем Указатель которы йдолжен будет содержать в себе 
адрес памяти на Структуру типа `Custom`.

Теперть мы можем обратиться к структуре 2 способами, либо через саму
переменную `cst` 
1) Способ


    cout << "ID = " << cst.id << endl; 
    cout << "NAME = " << cst.name << endl; 

2) Способ, тут мы обращаемся к Структуре через ссылку(Указатель), но 
чтобы расшифровать адрес в памяти, и получить доступ к значению в переменной 
используем оператор разименовая.

   
    cout << "ID = " << (*pointer).id << endl;
    cout << "NAME = " << (*pointer).name << endl; 


Второй способ позволяет обратиться к структуре через Указатель на нее,
но форма его записи неудобна, поэтому был добавлен синтаксичейский сахар.

###Оператор доступа к Структуре/Классу через Указатель
Удобный способ для доступа через стрелку -> 

Следующие 2 способа доступа эквивалентны:

    cout << "ID = " << (*pointer).id << endl;
    cout << "NAME = " << (*pointer).name << endl; 

    cout << "ID = " << pointer->id << endl;
    cout << "NAME = " << pointer->name << endl; 

