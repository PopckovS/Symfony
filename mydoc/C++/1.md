##Язык программирования C++ Урок №1
В Linux для работы с языком `C++` пользуется его компилятор `g++`
проверим его версию

    g++ --version

И получим ответ о текущей версии компилятора для C++

    g++ (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0

Сам компилятор C++ стоит из 4-х частей:

#####1) cpp — препроцессор
#####2) as — ассемблер
#####2) g++ — сам компилятор
#####4) ld — линкер

Исходный `C++` файл — это всего лишь код, по сути просто текст написанный в 
файле не более, его невозможно запустить как программу самомстоятельно. 
По этому каждый исходный файлтребуется скомпилировать в исполняемый файл.

###Этапы Компиляции
сходные файлы для `C++` имеют расширение .cpp 

К примеру сделаем такой файл с названием `index.cpp`

    #include <iostream>
    using namespace std;
    #define RETURN return 0

    int main(){
        cout << "Hello, world!" << endl;
        RETURN;
    }

###1) Этап первый Препроцессинг
Самая первая стадия компиляции программы.

Препроцессор - это макро процессор, который преобразовывает вашу программу 
для дальнейшего компилирования. Препроцессор добавляет хэдэры в код `#include`
Уберает коментирование, заменяет макросы `#define` их значениями, обрабатывает 
условия в соответствии с тем что было выбрано в `#if #ifdef`

Хэдэры что включены в программу с помощбю директивы `#include` проходят стадию
препроцессинга, и вкоючаются в выпускаемый файл. По скольку каждый Хэдер может 
быть открыт несколько раз, по этому  препроцессор пердохраняет от повторного 
подключения. 

После препроцессинга у нас формируется файл типа `index.ii`
(прошедшие через стадию препроцессинга C++ файлы имеют расширение .ii),

Обычно все процессы от исходных файлов до компиляции проходят сразу, но для 
наглядности пройдемся по этим процессам поэтапно. Для компиляции используется 
компилятор `g++` используем его но укажем дополнительный флаг `-E` для того чтобы 
исходный файл прошел только первый этап, этап Препроцессинга.

    g++ -E driver.cpp -o driver.ii

После этого произойдет подключение `#include <iostream>` и сама программа написанная
нами изменится на следующий код, где мы можем видеть что макрос RETURN был заменен.

    int main(){
        cout << "Hello, world!" << endl;
        return 0;
    }

Так образом наша изначальная программа выросла на аж 28 тычсяч строк.

####2) Этап второй Компиляция
На данном этапе `g++` выполняет свою главную задачу, он копилирует. Тоесть
преобразует  полученный на этапе Препроцессорный код в код `Ассемблера`.

Это промежутойный шаг между высокоуровневым языком `C++` и `машинным(бинарным)` кодом.

**Ассемблерный код** — это доступное для понимания человеком представление 
машинного кода.

Используя флаг `-S`, который сообщает компилятору остановиться после стадии компиляции, 
получим ассемблерный код в выходном файле index.s:

    g++ -S index.ii -o index.s

Таким образом получим новый файл в ккотором содержится код Ассемблера, выглядит он 
примерно следующим образом:

    .file	"index.cpp"
    	.text
    	.section	.rodata
    	.type	_ZStL19piecewise_construct, @object
    	.size	_ZStL19piecewise_construct, 1
    _ZStL19piecewise_construct:
    	.zero	1
    	.local	_ZStL8__ioinit
    	.comm	_ZStL8__ioinit,1,1
    .LC0:
    	.string	"Hello, world!"
    	.text
    	.globl	main
    	.type	main, @function
    main: 

В результате 28 000 строк кода на `C++` преобразуются в 100 строчек кода Ассемблера.

####3) Этап третий Ассемблирование
На этом этапе переведем Ассемблерный код в Машинный. Ассемблер преобразует свой код
в Машинный и сохраняет его в **`обьектный файл`**

####Обьектный файл 
Это созданный ассемблером промежуточный файл, в котором хранится кусочек 
машинного кода. Этот код назвывается `Обьектным кодом` и он еще не связан сдругими
кусками машинного кода.

Получим уже конечный Машинный код с помощью Ассемблера в выходной обьектный файл
`index.o` Для этого используем уже сам ассемблер и его утилиту `as` 

    as index.s -o index.o

####4) Этап Четвертый Компановка
После получения фала с Машинным кодом, надо соеденить его в исполняемый файл с 
помощью компановщика.

**Компановщик(Линкер)** - Связывает все обьектный файлы и статические библиотеки
в единый Исполняемый файл, который уже можно запустить.

Для того чтобы понять как происходит связываение обьектныйх файлов в единый 
Исполняемый файл, следует разобраться что из себя представляет `Таблица символов`.

**Таблица символов** - Это структура данных, которая создается компилятором и 
хранится в самих исполняемых файлах, эта таблица хранит в себе имена переменных,
функций,лассов, обьектов. Где для каждого эллемента таблицы описаны его тип и обл
видимости. Также каждая таблица символов хранит в себе не только описание своего файла
но и ссылки на другие файлы.

Используя эти таблицы символов Компановщик(Линкер) устанавливает связи между 
обьектными файлами, и собирает из них финальный Исполняемый файл. ам компановщик
явл частью Компилятора `g++` так что используем его чтобы получить Исполныемый файл.

    g++ index.o -o index

В результате поолучаем чистый Исполняемый файл `index` торый уже можно запустить 
при помощи команды

    ./index

И получаем результат

    Hello, world!
     
Все сработало как надо.
