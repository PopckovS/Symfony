##SQL Урок 7 

ambiguous - двусмысленный
grinning - Ухмыляющийся
grinned  - Ухмылялся 


По мимо самих JOIN можно делать обьеденения при помощи обычного WHERE.
По сути это есть не что иное как INNER JOIN, это еще называется
Декартово произведенеи - все строки одной таблицы устанавливают связи
со всеми строками другой таблицы, при запрсое формируется временная таблица
в которой каждой записи из одной таблицы, сопоставлена каждая строка другой
таблицы. А после мы изымаем из этой таблицы данные что по некому полю имеют
связь.

    SELECT vend_name, prod_name, prod_price
    FROM Vendors, Products
    WHERE Vendors.vend_id = Products.vend_id;

Однако тут будет выдана ошибка в случае если, у обоих таблиц есть 2 
поля с одинаковым названием.

###Обьединение таблиц INNER/LEFT/RIGHT/FULL JOIN
![](img/Screenshot from 2020-12-25 02-08-30.png)

#### INNER JOIN
![](img/Screenshot from 2020-12-25 02-10-09.png)

Стандартный JOIN выбирает данные что по некотрому полю пересекаются
из обеих таблиц, этот оператор срабатывает по умолчанию если пишим просто
слово JOIN.

![](img/Screenshot from 2020-12-25 02-43-48.png)

    SELECT * 
    FROM Messages 
    INNER JOIN Files ON Messages.fid = Files.fid

Этот запрсо создает таблицу которая будет состоять из данных у которых есть 
связь в обоих таблицах. Видим что в табл Messages есть только одно поле id = 2 
которое также присутствует в таблице Files таким образом мы получаем одну
записть:

    mid	  | bodytext  | fid	 |  path
    ---------------------------------------
    2	  | Hi	      | 2  	 |  /files/2.png

Тоетсь там где в таблицах записи совпадают по полю fid и происходит 
выборка данных.

#### LEFT JOIN 
![](img/Screenshot from 2020-12-25 02-30-54.png)

При левом обьеденении мы выводим все записи что етсь в левой таблицы, в данном
случае это Messages, и в том числе и те записи в которых значение fid есть в 
таблицу Files.

    SELECT * 
    FROM Messages
    LEFT JOIN Files ON Messages.fid = Files.fid



#### LEFT JOIN без пересечения с левой таблицей









