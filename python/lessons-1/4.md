## Урок 4. Модули
Существует 2 способа создания модулей:

1. Создать файл с расширением .py и писать код в нем.
2. Создать модуль на языке C на котором написан сам Питон.

#### Как импортировать модули:

    import sys

    print('ргументы командной строки:')
    for i in sys.argv:
        print(i)

    print('\nПеременная PYTHONPATH содержит:')
    for i in sys.path:
        print(i)

### Модуль sys
sys - это модуль что используется для работы с интерпритаором, 
также он может работать с командной строкой.

Когда происходит выполнение команды `import sys` модуль импортируется
в программу, данный модуль уже скомпилирован так что он подключется сразу,
еслибы это был модуль написанный на Python то его поиск проиходил бы в 
одной из переменных что указаны в `sys.path`

#### sys.path

Переменная sys.path содержит:
    
    ' '
    /var/www/Symfony/python/lessons-1/programm
    /usr/lib/python36.zip
    /usr/lib/python3.6
    /usr/lib/python3.6/lib-dynload
    /home/serg/.local/lib/python3.6/site-packages
    /usr/local/lib/python3.6/dist-packages
    /usr/lib/python3/dist-packages

Видим что вторая строка содержит путь `/var/www/Symfony/python/lessons-1/programm`
по которому и находится наша программа, тоетсь тем самым если мы импортируем
некий самописный модуль, который находится на том же уровне где и наша 
исполняемая программа, то именно эта первая строка пути и подключит нужный 
нам модуль.

Чтобы сдлеать свой модуль доступным для импортирования, нужно пооместить его в 
один из указанных путей, и он будет доступен.

#### sys.argv
Переменная argv модуля argv содержит те параметры что будут переданы в
программу при ее запуске из терминала, 

Запуске такой команды в териманле:
    
    ./1.py привет мир
        
    // Вывод
    ./1.py
    привет
    мир

### Модуль os
os - это модуль что предназначен для работы с операционной системой,
его функция `getcwd()` содержит путь до того файла, который был запущен 
на исполнение, в данном случае это 
`/var/www/Symfony/python/lessons-1/programm`

    import os

    print(os.getcwd())

### Файлы байткода .pyc
После того как модуль был импортирован один раз, этот модуль копируется
и переводится в промежуточную между кодом Python и двоичным кодом -
байткод, после чего сохраняется и при последующем использовании,
уже будет импортироваться этот самый байткод, что будет ускорять работу.

Файл .pyc с байткод будет помещен в туже папку в которой хранится сам 
изначальный файл .py

### Оператор from ... import ...
Обычно мы импортируем модуль так: `import sys` и каждый раз обращаясь к 
переменной в которой хранятся параметры запуска скрипта, нам треюуется 
писать `sys.argv`

Для того чтобы иметь возможность писать просто `argv` мы можем 
импортировать саму переменную `sys.argv` cделаем это так:

    from sys import argv

Таким образом теперь в коде мы можем обращаться к переменной как `argv`

Но так мы импортировали только одну переменную, если нам требуется 
импортировать все переменные из модуля `sys` то сделать это можно так:

    from sys import *

Но в случае если у нас есть просто переменная argv то это может привести
к конфликту имен переменных.

### Имя модуля `__name__`
У каждого модуля есть свое имя, которое хранится в переменной `__name__`.
Когда модуль работает самостоятельно, то его переменная равна `__main__`.
Но когда мы испортируем этот модуль, тоесть когда мы запускаем эту программу
как сторонний модуль, то его имя хранящиеся в переменной `__name__` меняется.

Таким образом в зависимости от того какой имя хранится в этой переменной, мы
можем узнать выполняется программа самостоятельно, или как импортированный 
модуль.

Сама модульная переменная `__name__` в нутри самого модуля, так и доступна,
так к ней и можно обращаться, как `__name__`

К примеру так:

Первый файл one.py

    print('Это программа one.py')
    def func():
        if __name__ == '__main__':
            print('Эта программа выполняется сама по себе')
        else:
            print('Эта программа запущена как импортированный модуль')
    func()

Второй файл two.py

    import one
    print('Это программа two.py')

Если запускаем программу `one.py` получаем:

    Это программа one.py
    Эта программа выполняется сама по себе

Мы запускаем файл `two.py` в нутри которого импортируется `one.py` 
то получаем:

    Это программа one.py
    Эта программа запущена как импортированный модуль
    Это программа two.py

По скольку мы запускаем файл one и в нем сразу делаем выполнение функции 
func() то ее код исполняется сразуже.

Когда мы импортируем модуль one в программу two то видим что код программы
one исполняется сразуже, его исполнение происходит сразу, еще в момент импорта.

Таким образом на основе переменной `__name__`  и условия if на проверку ее имени
как `__main__` мы можем определить запущена программа как самостоятельная или 
как модуль.

### Создание собственных Модулей
Каждая отдельная программа в Python уже является модулем, который можно 
импортировать, нужно всего лишь чтобы программа имела расширение .py 

Создадим модуль `mymodule.py` :

    def sayhi():
        print('Привет! Это говорит мой модуль.')
    __version__ = '0.1'

И импортируем его в другую программу:

    import mymodule
    mymodule.sayhi()
    print ('Версия', mymodule.__version__)

Как видим по мимо переменной `__name__` есть еще переменная `__version__`
в которой мы можем описать версию программы.

### Функция dir 
dir - Функция которая получает список всех сущьностей модуля,
таких как функции, классы и переменные этого модуля.

Передаем в функцию dir имя модуля и получаем список всех ее сущьностей, 
если непередовать никаких аргументов, то будет возвращен список всех 
сущьностей текущего модуля.

Когда мы получаем список всех всех сущьностей при помощи dir можно 
увидеть что есть и списки всех импортируемых модулей тоже.

!!! Также по мимо просмотра сущьностей модуля, можно смотреть и сущьности 
конкретных функций, для этого следует передать название этой функции, 
выглядит это следующим образом, получим список всех свойств функции print()

    print(dir(print()))

    ['__bool__', '__class__', '__delattr__', '__dir__', 
    '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', 
    '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', 
    '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', 
    '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']

### Пакеты
Пакеты - это просто каталоги с модулями и одним специальным файлом 
`__init__.py` который указывает Python что этот каталог особенный.

Также пакеты могут нажодиться в нутри пакетов, сделаем следующий пакет
`world` с 2 субпакетами `asia` и `africa` которые в свою очередь будут 
содержать пакеты `india` и `madagascar` так получим след структуру:


    world/
        __init__.py

        asia/
            __init__.py
            india/
                __init__.py
                foo.py
    
        africa/
            __init__.py
            madagascar/
                __init__.py
                bar.py

























